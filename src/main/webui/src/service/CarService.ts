/**
 * Generated by orval v8.0.0-rc.6 ðŸº
 * Do not edit manually.
 * Quarkus PrimeReact Monorepo
 * Quarkus monorepo demonstrating Panache REST server with PrimeReact UI client
 * OpenAPI spec version: 1.0.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
	DataTag,
	DefinedInitialDataOptions,
	DefinedUseQueryResult,
	MutationFunction,
	QueryClient,
	QueryFunction,
	QueryKey,
	UndefinedInitialDataOptions,
	UseMutationOptions,
	UseMutationResult,
	UseQueryOptions,
	UseQueryResult
} from '@tanstack/react-query';

import { useCallback } from 'react';

import { useAxiosMutator } from './AxiosMutator';
import type { ErrorType } from './AxiosMutator';
export type Instant = Date;

/**
 * Entity that represents a car.
 */
export interface Car {
	id?: number;
	/**
	 * VIN number
	 * @maxLength 17
	 * @pattern \S
	 */
	vin: string;
	/**
	 * Manufacturer
	 * @maxLength 255
	 * @pattern \S
	 */
	make: string;
	/**
	 * Model Number
	 * @maxLength 255
	 * @pattern \S
	 */
	model: string;
	/**
	 * Year of manufacture
	 * @minimum 1960
	 * @maximum 2050
	 */
	year: number;
	/**
	 * HTML color of the car
	 * @maxLength 20
	 * @pattern \S
	 */
	color: string;
	/**
	 * Price
	 * @minimum 0
	 * @maximum 250000
	 */
	price: number;
	/** Modified time of the record */
	modifiedTime?: Instant;
}

export interface FilterConstraint {
	/** Value to filter this column by */
	value?: unknown;
	/** Filter match mode e.g. equals, notEquals, contains, notContains, gt, gte, lt, lte */
	matchMode?: string;
}

/**
 * HTTP Problem Response according to RFC9457 and RFC7807
 */
export interface HttpProblem {
	/** A optional URI reference that identifies the problem type */
	type?: string;
	/** A optional, short, human-readable summary of the problem type */
	title?: string;
	/** The HTTP status code for this occurrence of the problem */
	status?: number;
	/** A optional human-readable explanation specific to this occurrence of the problem */
	detail?: string;
	/** A URI reference that identifies the specific occurrence of the problem */
	instance?: string;
	[key: string]: unknown;
}

/**
 * Validation constraint violation details
 */
export interface Violation {
	/** The field for which the validation failed */
	field?: string;
	/** Part of the http request where the validation error occurred such as query, path, header, form, body */
	in?: string;
	/** Description of the validation error */
	message?: string;
}

/**
 * HTTP Validation Problem Response according to RFC9457 and RFC7807
 */
export interface HttpValidationProblem {
	/** A optional URI reference that identifies the problem type */
	type?: string;
	/** A optional, short, human-readable summary of the problem type */
	title?: string;
	/** The HTTP status code for this occurrence of the problem */
	status?: number;
	/** A optional human-readable explanation specific to this occurrence of the problem */
	detail?: string;
	/** A URI reference that identifies the specific occurrence of the problem */
	instance?: string;
	/** List of validation constraint violations that occurred */
	violations?: Violation[];
	[key: string]: unknown;
}

export interface MultiFilterMeta {
	/** Value to filter this column by */
	value?: unknown;
	/** Filter match mode e.g. equals, notEquals, contains, notContains, gt, gte, lt, lte */
	matchMode?: string;
	/** Filter operator either 'and' or 'or' */
	operator?: string;
	/** List of filter constraints for this filter */
	constraints?: FilterConstraint[];
}

export interface MultiSortMeta {
	/** Sort field for this multiple sort */
	field?: string;
	/** Sort order for this field either -1 desc, 0 none, 1 asc */
	order?: number;
}

/**
 * Map of columns being filtered and their filter criteria
 */
export type QueryRequestFilters = { [key: string]: MultiFilterMeta };

/**
 * Represents a PrimeReact query request from the UI for a complex datatable with multiple sorts, multiple filters, and pagination.
 */
export interface QueryRequest {
	/** First record */
	first?: number;
	/** Number of rows */
	rows?: number;
	/** Page number */
	page?: number;
	/** Sort field if single field sorting */
	sortField?: string;
	/** Sort order if single field sorting either -1 desc, 0 none, 1 asc */
	sortOrder?: number;
	/** Multiple sorting list of columns to sort and in which order */
	multiSortMeta?: MultiSortMeta[];
	/** Map of columns being filtered and their filter criteria */
	filters?: QueryRequestFilters;
}

/**
 * Represents a PrimeReact query response to the UI for a complex datatable with multiple sorts, multiple filters, and pagination.
 */
export interface QueryResponse {
	/** Total records available by this query criteria */
	totalRecords?: number;
	/** Records for this set of pagination, sorting, filtering. */
	records?: unknown[];
}

/**
 * Represents a PrimeReact query response to the UI for a complex datatable with multiple sorts, multiple filters, and pagination.
 */
export interface QueryResponseCar {
	/** Total records available by this query criteria */
	totalRecords?: number;
	/** Records for this set of pagination, sorting, filtering. */
	records?: Car[];
}

/**
 * Additional context information for the message
 */
export type SocketMessageContext = { [key: string]: string };

export type ZonedDateTime = Date;

export type SocketMessageType = (typeof SocketMessageType)[keyof typeof SocketMessageType];

export const SocketMessageType = {
	REFRESH_DATA: 'REFRESH_DATA',
	NOTIFICATION: 'NOTIFICATION'
} as const;

/**
 * WebSocket message for real-time updates
 */
export interface SocketMessage {
	/** Unique identifier for the message */
	id?: string;
	/** UTC timestamp of when the message was created */
	timestamp?: ZonedDateTime;
	/** Type of socket message */
	type: SocketMessageType;
	/** Optional message payload */
	message?: string;
	/** Additional context information for the message */
	context?: SocketMessageContext;
}

export type LoggerLevel = (typeof LoggerLevel)[keyof typeof LoggerLevel];

export const LoggerLevel = {
	OFF: 'OFF',
	SEVERE: 'SEVERE',
	ERROR: 'ERROR',
	FATAL: 'FATAL',
	WARNING: 'WARNING',
	WARN: 'WARN',
	INFO: 'INFO',
	DEBUG: 'DEBUG',
	TRACE: 'TRACE',
	CONFIG: 'CONFIG',
	FINE: 'FINE',
	FINER: 'FINER',
	FINEST: 'FINEST',
	ALL: 'ALL'
} as const;

export interface LoggerInfo {
	configuredLevel?: LoggerLevel;
	effectiveLevel?: LoggerLevel;
	name?: string;
}

export type HealthResponseStatus = (typeof HealthResponseStatus)[keyof typeof HealthResponseStatus];

export const HealthResponseStatus = {
	UP: 'UP',
	DOWN: 'DOWN'
} as const;

export type HealthCheckStatus = (typeof HealthCheckStatus)[keyof typeof HealthCheckStatus];

export const HealthCheckStatus = {
	UP: 'UP',
	DOWN: 'DOWN'
} as const;

/**
 * @nullable
 */
export type HealthCheckData = { [key: string]: unknown } | null | null;

export interface HealthCheck {
	/** @nullable */
	data?: HealthCheckData;
	name?: string;
	status?: HealthCheckStatus;
}

export interface HealthResponse {
	checks?: HealthCheck[];
	status?: HealthResponseStatus;
}

export type GetEntityCarsParams = {
	request?: string;
};

export type PostSocketNotifyParams = {
	message?: string;
};

export type LoggingManagerGetAllParams = {
	loggerName?: string;
};

export type LoggingManagerUpdateParams = {
	/**
	 * Used to set the log level temporarily
	 */
	temporary?: boolean;
};

export type LoggingManagerUpdateBody = {
	loggerName?: string;
	loggerLevel?: LoggerLevel;
	/** Duration in seconds, used only if temporary=true */
	duration?: number;
};

/**
 * Returns a paginated list of cars with optional filtering and sorting
 * @summary List cars
 */
export const useGetEntityCarsHook = () => {
	const getEntityCars = useAxiosMutator<QueryResponseCar>();

	return useCallback(
		(params?: GetEntityCarsParams, signal?: AbortSignal) => {
			return getEntityCars({ url: `/entity/cars`, method: 'GET', params, signal });
		},
		[getEntityCars]
	);
};

export const getGetEntityCarsQueryKey = (params?: GetEntityCarsParams) => {
	return [`/entity/cars`, ...(params ? [params] : [])] as const;
};

export const useGetEntityCarsQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError = ErrorType<HttpProblem>>(
	params?: GetEntityCarsParams,
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError, TData>> }
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetEntityCarsQueryKey(params);

	const getEntityCars = useGetEntityCarsHook();

	const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>> = ({ signal }) => getEntityCars(params, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError, TData> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};
};

export type GetEntityCarsQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>>;
export type GetEntityCarsQueryError = ErrorType<HttpProblem>;

export function useGetEntityCars<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError = ErrorType<HttpProblem>>(
	params: undefined | GetEntityCarsParams,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetEntityCars<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError = ErrorType<HttpProblem>>(
	params?: GetEntityCarsParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetEntityCars<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError = ErrorType<HttpProblem>>(
	params?: GetEntityCarsParams,
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary List cars
 */

export function useGetEntityCars<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError = ErrorType<HttpProblem>>(
	params?: GetEntityCarsParams,
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = useGetEntityCarsQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Creates a new car entry
 * @summary Create a new car
 */
export const usePostEntityCarsHook = () => {
	const postEntityCars = useAxiosMutator<Car>();

	return useCallback(
		(car: Car, signal?: AbortSignal) => {
			return postEntityCars({ url: `/entity/cars`, method: 'POST', headers: { 'Content-Type': 'application/json' }, data: car, signal });
		},
		[postEntityCars]
	);
};

export const usePostEntityCarsMutationOptions = <TError = ErrorType<HttpProblem>, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePostEntityCarsHook>>>, TError, { data: Car }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePostEntityCarsHook>>>, TError, { data: Car }, TContext> => {
	const mutationKey = ['postEntityCars'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const postEntityCars = usePostEntityCarsHook();

	const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof usePostEntityCarsHook>>>, { data: Car }> = (props) => {
		const { data } = props ?? {};

		return postEntityCars(data);
	};

	return { mutationFn, ...mutationOptions };
};

export type PostEntityCarsMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof usePostEntityCarsHook>>>>;
export type PostEntityCarsMutationBody = Car;
export type PostEntityCarsMutationError = ErrorType<HttpProblem>;

/**
 * @summary Create a new car
 */
export const usePostEntityCars = <TError = ErrorType<HttpProblem>, TContext = unknown>(
	options?: { mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePostEntityCarsHook>>>, TError, { data: Car }, TContext> },
	queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<ReturnType<typeof usePostEntityCarsHook>>>, TError, { data: Car }, TContext> => {
	return useMutation(usePostEntityCarsMutationOptions(options), queryClient);
};

/**
 * Returns a list of distinct car manufacturers
 * @summary Get all manufacturers
 */
export const useGetEntityCarsManufacturersHook = () => {
	const getEntityCarsManufacturers = useAxiosMutator<string[]>();

	return useCallback(
		(signal?: AbortSignal) => {
			return getEntityCarsManufacturers({ url: `/entity/cars/manufacturers`, method: 'GET', signal });
		},
		[getEntityCarsManufacturers]
	);
};

export const getGetEntityCarsManufacturersQueryKey = () => {
	return [`/entity/cars/manufacturers`] as const;
};

export const useGetEntityCarsManufacturersQueryOptions = <
	TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>,
	TError = ErrorType<unknown>
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>, TError, TData>>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetEntityCarsManufacturersQueryKey();

	const getEntityCarsManufacturers = useGetEntityCarsManufacturersHook();

	const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>> = ({ signal }) =>
		getEntityCarsManufacturers(signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEntityCarsManufacturersQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>>;
export type GetEntityCarsManufacturersQueryError = ErrorType<unknown>;

export function useGetEntityCarsManufacturers<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>, TError = ErrorType<unknown>>(
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetEntityCarsManufacturers<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>, TError = ErrorType<unknown>>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetEntityCarsManufacturers<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>, TError = ErrorType<unknown>>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get all manufacturers
 */

export function useGetEntityCarsManufacturers<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>, TError = ErrorType<unknown>>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsManufacturersHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = useGetEntityCarsManufacturersQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Updates an existing car based on ID
 * @summary Update a car
 */
export const usePutEntityCarsIdHook = () => {
	const putEntityCarsId = useAxiosMutator<Car>();

	return useCallback(
		(id: number, car: Car, signal?: AbortSignal) => {
			return putEntityCarsId({ url: `/entity/cars/${id}`, method: 'PUT', headers: { 'Content-Type': 'application/json' }, data: car, signal });
		},
		[putEntityCarsId]
	);
};

export const usePutEntityCarsIdMutationOptions = <TError = ErrorType<HttpProblem>, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePutEntityCarsIdHook>>>, TError, { id: number; data: Car }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePutEntityCarsIdHook>>>, TError, { id: number; data: Car }, TContext> => {
	const mutationKey = ['putEntityCarsId'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const putEntityCarsId = usePutEntityCarsIdHook();

	const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof usePutEntityCarsIdHook>>>, { id: number; data: Car }> = (props) => {
		const { id, data } = props ?? {};

		return putEntityCarsId(id, data);
	};

	return { mutationFn, ...mutationOptions };
};

export type PutEntityCarsIdMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof usePutEntityCarsIdHook>>>>;
export type PutEntityCarsIdMutationBody = Car;
export type PutEntityCarsIdMutationError = ErrorType<HttpProblem>;

/**
 * @summary Update a car
 */
export const usePutEntityCarsId = <TError = ErrorType<HttpProblem>, TContext = unknown>(
	options?: { mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePutEntityCarsIdHook>>>, TError, { id: number; data: Car }, TContext> },
	queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<ReturnType<typeof usePutEntityCarsIdHook>>>, TError, { id: number; data: Car }, TContext> => {
	return useMutation(usePutEntityCarsIdMutationOptions(options), queryClient);
};

/**
 * Returns a car based on the provided ID
 * @summary Get a car by ID
 */
export const useGetEntityCarsIdHook = () => {
	const getEntityCarsId = useAxiosMutator<Car>();

	return useCallback(
		(id: number, signal?: AbortSignal) => {
			return getEntityCarsId({ url: `/entity/cars/${id}`, method: 'GET', signal });
		},
		[getEntityCarsId]
	);
};

export const getGetEntityCarsIdQueryKey = (id?: number) => {
	return [`/entity/cars/${id}`] as const;
};

export const useGetEntityCarsIdQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError = ErrorType<HttpProblem>>(
	id: number,
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError, TData>> }
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getGetEntityCarsIdQueryKey(id);

	const getEntityCarsId = useGetEntityCarsIdHook();

	const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>> = ({ signal }) => getEntityCarsId(id, signal);

	return { queryKey, queryFn, enabled: !!id, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type GetEntityCarsIdQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>>;
export type GetEntityCarsIdQueryError = ErrorType<HttpProblem>;

export function useGetEntityCarsId<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError = ErrorType<HttpProblem>>(
	id: number,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetEntityCarsId<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError = ErrorType<HttpProblem>>(
	id: number,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useGetEntityCarsId<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError = ErrorType<HttpProblem>>(
	id: number,
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get a car by ID
 */

export function useGetEntityCarsId<TData = Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError = ErrorType<HttpProblem>>(
	id: number,
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useGetEntityCarsIdHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = useGetEntityCarsIdQueryOptions(id, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Deletes a car based on ID
 * @summary Delete a car
 */
export const useDeleteEntityCarsIdHook = () => {
	const deleteEntityCarsId = useAxiosMutator<void>();

	return useCallback(
		(id: number, signal?: AbortSignal) => {
			return deleteEntityCarsId({ url: `/entity/cars/${id}`, method: 'DELETE', signal });
		},
		[deleteEntityCarsId]
	);
};

export const useDeleteEntityCarsIdMutationOptions = <TError = ErrorType<HttpProblem>, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteEntityCarsIdHook>>>, TError, { id: number }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteEntityCarsIdHook>>>, TError, { id: number }, TContext> => {
	const mutationKey = ['deleteEntityCarsId'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const deleteEntityCarsId = useDeleteEntityCarsIdHook();

	const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof useDeleteEntityCarsIdHook>>>, { id: number }> = (props) => {
		const { id } = props ?? {};

		return deleteEntityCarsId(id);
	};

	return { mutationFn, ...mutationOptions };
};

export type DeleteEntityCarsIdMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useDeleteEntityCarsIdHook>>>>;

export type DeleteEntityCarsIdMutationError = ErrorType<HttpProblem>;

/**
 * @summary Delete a car
 */
export const useDeleteEntityCarsId = <TError = ErrorType<HttpProblem>, TContext = unknown>(
	options?: { mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof useDeleteEntityCarsIdHook>>>, TError, { id: number }, TContext> },
	queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<ReturnType<typeof useDeleteEntityCarsIdHook>>>, TError, { id: number }, TContext> => {
	return useMutation(useDeleteEntityCarsIdMutationOptions(options), queryClient);
};

/**
 * Pushes a notification message to all connected clients
 * @summary Push notification message
 */
export const usePostSocketNotifyHook = () => {
	const postSocketNotify = useAxiosMutator<void>();

	return useCallback(
		(params?: PostSocketNotifyParams, signal?: AbortSignal) => {
			return postSocketNotify({ url: `/socket/notify`, method: 'POST', params, signal });
		},
		[postSocketNotify]
	);
};

export const usePostSocketNotifyMutationOptions = <TError = ErrorType<HttpProblem>, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePostSocketNotifyHook>>>, TError, { params?: PostSocketNotifyParams }, TContext>;
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePostSocketNotifyHook>>>, TError, { params?: PostSocketNotifyParams }, TContext> => {
	const mutationKey = ['postSocketNotify'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const postSocketNotify = usePostSocketNotifyHook();

	const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof usePostSocketNotifyHook>>>, { params?: PostSocketNotifyParams }> = (props) => {
		const { params } = props ?? {};

		return postSocketNotify(params);
	};

	return { mutationFn, ...mutationOptions };
};

export type PostSocketNotifyMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof usePostSocketNotifyHook>>>>;

export type PostSocketNotifyMutationError = ErrorType<HttpProblem>;

/**
 * @summary Push notification message
 */
export const usePostSocketNotify = <TError = ErrorType<HttpProblem>, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePostSocketNotifyHook>>>, TError, { params?: PostSocketNotifyParams }, TContext>;
	},
	queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<ReturnType<typeof usePostSocketNotifyHook>>>, TError, { params?: PostSocketNotifyParams }, TContext> => {
	return useMutation(usePostSocketNotifyMutationOptions(options), queryClient);
};

/**
 * Pushes a UI refresh signal to all connected clients
 * @summary Push a UI refresh signal
 */
export const usePostSocketRefreshHook = () => {
	const postSocketRefresh = useAxiosMutator<void>();

	return useCallback(
		(signal?: AbortSignal) => {
			return postSocketRefresh({ url: `/socket/refresh`, method: 'POST', signal });
		},
		[postSocketRefresh]
	);
};

export const usePostSocketRefreshMutationOptions = <TError = ErrorType<unknown>, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePostSocketRefreshHook>>>, TError, void, TContext>;
}): UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePostSocketRefreshHook>>>, TError, void, TContext> => {
	const mutationKey = ['postSocketRefresh'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const postSocketRefresh = usePostSocketRefreshHook();

	const mutationFn: MutationFunction<Awaited<ReturnType<ReturnType<typeof usePostSocketRefreshHook>>>, void> = () => {
		return postSocketRefresh();
	};

	return { mutationFn, ...mutationOptions };
};

export type PostSocketRefreshMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof usePostSocketRefreshHook>>>>;

export type PostSocketRefreshMutationError = ErrorType<unknown>;

/**
 * @summary Push a UI refresh signal
 */
export const usePostSocketRefresh = <TError = ErrorType<unknown>, TContext = unknown>(
	options?: { mutation?: UseMutationOptions<Awaited<ReturnType<ReturnType<typeof usePostSocketRefreshHook>>>, TError, void, TContext> },
	queryClient?: QueryClient
): UseMutationResult<Awaited<ReturnType<ReturnType<typeof usePostSocketRefreshHook>>>, TError, void, TContext> => {
	return useMutation(usePostSocketRefreshMutationOptions(options), queryClient);
};

/**
 * Get information on all loggers or a specific logger.
 * @summary Information on Logger(s)
 */
export const useLoggingManagerGetAllHook = () => {
	const loggingManagerGetAll = useAxiosMutator<LoggerInfo[]>();

	return useCallback(
		(params?: LoggingManagerGetAllParams, signal?: AbortSignal) => {
			return loggingManagerGetAll({ url: `/q/logging-manager`, method: 'GET', params, signal });
		},
		[loggingManagerGetAll]
	);
};

export const getLoggingManagerGetAllQueryKey = (params?: LoggingManagerGetAllParams) => {
	return [`/q/logging-manager`, ...(params ? [params] : [])] as const;
};

export const useLoggingManagerGetAllQueryOptions = <TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError = ErrorType<void>>(
	params?: LoggingManagerGetAllParams,
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError, TData>> }
) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getLoggingManagerGetAllQueryKey(params);

	const loggingManagerGetAll = useLoggingManagerGetAllHook();

	const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>> = ({ signal }) => loggingManagerGetAll(params, signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError, TData> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};
};

export type LoggingManagerGetAllQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>>;
export type LoggingManagerGetAllQueryError = ErrorType<void>;

export function useLoggingManagerGetAll<TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError = ErrorType<void>>(
	params: undefined | LoggingManagerGetAllParams,
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLoggingManagerGetAll<TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError = ErrorType<void>>(
	params?: LoggingManagerGetAllParams,
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLoggingManagerGetAll<TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError = ErrorType<void>>(
	params?: LoggingManagerGetAllParams,
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Information on Logger(s)
 */

export function useLoggingManagerGetAll<TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError = ErrorType<void>>(
	params?: LoggingManagerGetAllParams,
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerGetAllHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = useLoggingManagerGetAllQueryOptions(params, options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Update a log level for a certain logger. Use query param `temporary=true` for temporary level.
 * @summary Update log level
 */
export const useLoggingManagerUpdateHook = () => {
	const loggingManagerUpdate = useAxiosMutator<void | void>();

	return useCallback(
		(loggingManagerUpdateBody: LoggingManagerUpdateBody, params?: LoggingManagerUpdateParams, signal?: AbortSignal) => {
			const formUrlEncoded = new URLSearchParams();
			if (loggingManagerUpdateBody.loggerName !== undefined) {
				formUrlEncoded.append(`loggerName`, loggingManagerUpdateBody.loggerName);
			}
			if (loggingManagerUpdateBody.loggerLevel !== undefined) {
				formUrlEncoded.append(`loggerLevel`, loggingManagerUpdateBody.loggerLevel);
			}
			if (loggingManagerUpdateBody.duration !== undefined) {
				formUrlEncoded.append(`duration`, loggingManagerUpdateBody.duration.toString());
			}

			return loggingManagerUpdate({
				url: `/q/logging-manager`,
				method: 'POST',
				headers: { 'Content-Type': 'application/x-www-form-urlencoded' },
				data: formUrlEncoded,
				params,
				signal
			});
		},
		[loggingManagerUpdate]
	);
};

export const useLoggingManagerUpdateMutationOptions = <TError = ErrorType<void>, TContext = unknown>(options?: {
	mutation?: UseMutationOptions<
		Awaited<ReturnType<ReturnType<typeof useLoggingManagerUpdateHook>>>,
		TError,
		{ data: LoggingManagerUpdateBody; params?: LoggingManagerUpdateParams },
		TContext
	>;
}): UseMutationOptions<
	Awaited<ReturnType<ReturnType<typeof useLoggingManagerUpdateHook>>>,
	TError,
	{ data: LoggingManagerUpdateBody; params?: LoggingManagerUpdateParams },
	TContext
> => {
	const mutationKey = ['loggingManagerUpdate'];
	const { mutation: mutationOptions } = options
		? options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey
			? options
			: { ...options, mutation: { ...options.mutation, mutationKey } }
		: { mutation: { mutationKey } };

	const loggingManagerUpdate = useLoggingManagerUpdateHook();

	const mutationFn: MutationFunction<
		Awaited<ReturnType<ReturnType<typeof useLoggingManagerUpdateHook>>>,
		{ data: LoggingManagerUpdateBody; params?: LoggingManagerUpdateParams }
	> = (props) => {
		const { data, params } = props ?? {};

		return loggingManagerUpdate(data, params);
	};

	return { mutationFn, ...mutationOptions };
};

export type LoggingManagerUpdateMutationResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useLoggingManagerUpdateHook>>>>;
export type LoggingManagerUpdateMutationBody = LoggingManagerUpdateBody;
export type LoggingManagerUpdateMutationError = ErrorType<void>;

/**
 * @summary Update log level
 */
export const useLoggingManagerUpdate = <TError = ErrorType<void>, TContext = unknown>(
	options?: {
		mutation?: UseMutationOptions<
			Awaited<ReturnType<ReturnType<typeof useLoggingManagerUpdateHook>>>,
			TError,
			{ data: LoggingManagerUpdateBody; params?: LoggingManagerUpdateParams },
			TContext
		>;
	},
	queryClient?: QueryClient
): UseMutationResult<
	Awaited<ReturnType<ReturnType<typeof useLoggingManagerUpdateHook>>>,
	TError,
	{ data: LoggingManagerUpdateBody; params?: LoggingManagerUpdateParams },
	TContext
> => {
	return useMutation(useLoggingManagerUpdateMutationOptions(options), queryClient);
};

/**
 * This returns all possible log levels
 * @summary Get all available levels
 */
export const useLoggingManagerLevelsHook = () => {
	const loggingManagerLevels = useAxiosMutator<LoggerLevel[]>();

	return useCallback(
		(signal?: AbortSignal) => {
			return loggingManagerLevels({ url: `/q/logging-manager/levels`, method: 'GET', signal });
		},
		[loggingManagerLevels]
	);
};

export const getLoggingManagerLevelsQueryKey = () => {
	return [`/q/logging-manager/levels`] as const;
};

export const useLoggingManagerLevelsQueryOptions = <
	TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>,
	TError = ErrorType<unknown>
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError, TData>>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getLoggingManagerLevelsQueryKey();

	const loggingManagerLevels = useLoggingManagerLevelsHook();

	const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>> = ({ signal }) => loggingManagerLevels(signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError, TData> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};
};

export type LoggingManagerLevelsQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>>;
export type LoggingManagerLevelsQueryError = ErrorType<unknown>;

export function useLoggingManagerLevels<TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError = ErrorType<unknown>>(
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLoggingManagerLevels<TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError = ErrorType<unknown>>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useLoggingManagerLevels<TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError = ErrorType<unknown>>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary Get all available levels
 */

export function useLoggingManagerLevels<TData = Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError = ErrorType<unknown>>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useLoggingManagerLevelsHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = useLoggingManagerLevelsQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Check the health of the application
 * @summary An aggregated view of the Liveness, Readiness and Startup of this application
 */
export const useMicroprofileHealthRootHook = () => {
	const microprofileHealthRoot = useAxiosMutator<HealthResponse>();

	return useCallback(
		(signal?: AbortSignal) => {
			return microprofileHealthRoot({ url: `/q/health`, method: 'GET', signal });
		},
		[microprofileHealthRoot]
	);
};

export const getMicroprofileHealthRootQueryKey = () => {
	return [`/q/health`] as const;
};

export const useMicroprofileHealthRootQueryOptions = <
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>,
	TError = ErrorType<HealthResponse>
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError, TData>>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getMicroprofileHealthRootQueryKey();

	const microprofileHealthRoot = useMicroprofileHealthRootHook();

	const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>> = ({ signal }) => microprofileHealthRoot(signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError, TData> & {
		queryKey: DataTag<QueryKey, TData, TError>;
	};
};

export type MicroprofileHealthRootQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>>;
export type MicroprofileHealthRootQueryError = ErrorType<HealthResponse>;

export function useMicroprofileHealthRoot<TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError = ErrorType<HealthResponse>>(
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMicroprofileHealthRoot<TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError = ErrorType<HealthResponse>>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMicroprofileHealthRoot<TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError = ErrorType<HealthResponse>>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary An aggregated view of the Liveness, Readiness and Startup of this application
 */

export function useMicroprofileHealthRoot<TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError = ErrorType<HealthResponse>>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthRootHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = useMicroprofileHealthRootQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Check the liveness of the application
 * @summary The Liveness check of this application
 */
export const useMicroprofileHealthLivenessHook = () => {
	const microprofileHealthLiveness = useAxiosMutator<HealthResponse>();

	return useCallback(
		(signal?: AbortSignal) => {
			return microprofileHealthLiveness({ url: `/q/health/live`, method: 'GET', signal });
		},
		[microprofileHealthLiveness]
	);
};

export const getMicroprofileHealthLivenessQueryKey = () => {
	return [`/q/health/live`] as const;
};

export const useMicroprofileHealthLivenessQueryOptions = <
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>,
	TError = ErrorType<HealthResponse>
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>, TError, TData>>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getMicroprofileHealthLivenessQueryKey();

	const microprofileHealthLiveness = useMicroprofileHealthLivenessHook();

	const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>> = ({ signal }) =>
		microprofileHealthLiveness(signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MicroprofileHealthLivenessQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>>;
export type MicroprofileHealthLivenessQueryError = ErrorType<HealthResponse>;

export function useMicroprofileHealthLiveness<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMicroprofileHealthLiveness<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMicroprofileHealthLiveness<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary The Liveness check of this application
 */

export function useMicroprofileHealthLiveness<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthLivenessHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = useMicroprofileHealthLivenessQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Check the readiness of the application
 * @summary The Readiness check of this application
 */
export const useMicroprofileHealthReadinessHook = () => {
	const microprofileHealthReadiness = useAxiosMutator<HealthResponse>();

	return useCallback(
		(signal?: AbortSignal) => {
			return microprofileHealthReadiness({ url: `/q/health/ready`, method: 'GET', signal });
		},
		[microprofileHealthReadiness]
	);
};

export const getMicroprofileHealthReadinessQueryKey = () => {
	return [`/q/health/ready`] as const;
};

export const useMicroprofileHealthReadinessQueryOptions = <
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>,
	TError = ErrorType<HealthResponse>
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>, TError, TData>>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getMicroprofileHealthReadinessQueryKey();

	const microprofileHealthReadiness = useMicroprofileHealthReadinessHook();

	const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>> = ({ signal }) =>
		microprofileHealthReadiness(signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MicroprofileHealthReadinessQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>>;
export type MicroprofileHealthReadinessQueryError = ErrorType<HealthResponse>;

export function useMicroprofileHealthReadiness<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMicroprofileHealthReadiness<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMicroprofileHealthReadiness<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary The Readiness check of this application
 */

export function useMicroprofileHealthReadiness<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthReadinessHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = useMicroprofileHealthReadinessQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}

/**
 * Check the startup of the application
 * @summary The Startup check of this application
 */
export const useMicroprofileHealthStartupHook = () => {
	const microprofileHealthStartup = useAxiosMutator<HealthResponse>();

	return useCallback(
		(signal?: AbortSignal) => {
			return microprofileHealthStartup({ url: `/q/health/started`, method: 'GET', signal });
		},
		[microprofileHealthStartup]
	);
};

export const getMicroprofileHealthStartupQueryKey = () => {
	return [`/q/health/started`] as const;
};

export const useMicroprofileHealthStartupQueryOptions = <
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>,
	TError = ErrorType<HealthResponse>
>(options?: {
	query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>, TError, TData>>;
}) => {
	const { query: queryOptions } = options ?? {};

	const queryKey = queryOptions?.queryKey ?? getMicroprofileHealthStartupQueryKey();

	const microprofileHealthStartup = useMicroprofileHealthStartupHook();

	const queryFn: QueryFunction<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>> = ({ signal }) => microprofileHealthStartup(signal);

	return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
		Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>,
		TError,
		TData
	> & { queryKey: DataTag<QueryKey, TData, TError> };
};

export type MicroprofileHealthStartupQueryResult = NonNullable<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>>;
export type MicroprofileHealthStartupQueryError = ErrorType<HealthResponse>;

export function useMicroprofileHealthStartup<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options: {
		query: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>, TError, TData>> &
			Pick<
				DefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMicroprofileHealthStartup<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options?: {
		query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>, TError, TData>> &
			Pick<
				UndefinedInitialDataOptions<
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>,
					TError,
					Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>
				>,
				'initialData'
			>;
	},
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
export function useMicroprofileHealthStartup<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };
/**
 * @summary The Startup check of this application
 */

export function useMicroprofileHealthStartup<
	TData = Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>,
	TError = ErrorType<HealthResponse>
>(
	options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<ReturnType<typeof useMicroprofileHealthStartupHook>>>, TError, TData>> },
	queryClient?: QueryClient
): UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {
	const queryOptions = useMicroprofileHealthStartupQueryOptions(options);

	const query = useQuery(queryOptions, queryClient) as UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

	return { ...query, queryKey: queryOptions.queryKey };
}
